{"ast":null,"code":"import { DIRECTION, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\n/** Dynamic mask for choosing appropriate mask in run-time */\nclass MaskedDynamic extends Masked {\n  // TODO types\n  /** Currently chosen mask */\n  /** Compliled {@link Masked} options */\n  // TODO FactoryReturnMasked<?>\n  /** Chooses {@link Masked} depending on input value */\n  constructor(opts) {\n    super({\n      ...MaskedDynamic.DEFAULTS,\n      ...opts\n    });\n    this.currentMask = null;\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    super._update(opts);\n    if ('mask' in opts) {\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => createMask(m)) : [];\n\n      // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const details = this._applyDispatch(ch, flags);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n    return details;\n  }\n  _applyDispatch(appended, flags, tail) {\n    if (appended === void 0) {\n      appended = '';\n    }\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (tail === void 0) {\n      tail = '';\n    }\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask == null ? void 0 : prevMask.state;\n\n    // clone flags to prevent overwriting `_beforeTailState`\n    this.currentMask = this.doDispatch(appended, {\n      ...flags\n    }, tail);\n\n    // restore state after dispatch\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n        if (insertValue) {\n          const d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n        }\n        if (tailValue) {\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n    return details;\n  }\n  _appendPlaceholder() {\n    const details = this._applyDispatch();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n    return details;\n  }\n  _appendEager() {\n    const details = this._applyDispatch();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n    return details;\n  }\n  appendTail(tail) {\n    const details = new ChangeDetails();\n    if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n    return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\n  }\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n    return {\n      ...flags,\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    };\n  }\n  doDispatch(appended, flags, tail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (tail === void 0) {\n      tail = '';\n    }\n    return this.dispatch(appended, this, flags, tail);\n  }\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n  doPrepare(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let [s, details] = super.doPrepare(str, flags);\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepare(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n  doPrepareChar(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let [s, details] = super.doPrepareChar(str, flags);\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepareChar(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n  reset() {\n    var _this$currentMask;\n    (_this$currentMask = this.currentMask) == null ? void 0 : _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n  get value() {\n    return this.currentMask ? this.currentMask.value : '';\n  }\n  set value(value) {\n    super.value = value;\n  }\n  get unmaskedValue() {\n    return this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n  get typedValue() {\n    return this.currentMask ? this.currentMask.typedValue : '';\n  }\n\n  // probably typedValue should not be used with dynamic\n  set typedValue(value) {\n    let unmaskedValue = String(value);\n\n    // double check it\n    if (this.currentMask) {\n      this.currentMask.typedValue = value;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n    this.unmaskedValue = unmaskedValue;\n  }\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n  get isComplete() {\n    var _this$currentMask2;\n    return Boolean((_this$currentMask2 = this.currentMask) == null ? void 0 : _this$currentMask2.isComplete);\n  }\n  get isFilled() {\n    var _this$currentMask3;\n    return Boolean((_this$currentMask3 = this.currentMask) == null ? void 0 : _this$currentMask3.isFilled);\n  }\n  remove(fromPos, toPos) {\n    const details = new ChangeDetails();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(fromPos, toPos))\n      // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n    return details;\n  }\n  get state() {\n    var _this$currentMask4;\n    return {\n      ...super.state,\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) == null ? void 0 : _this$currentMask4.state\n    };\n  }\n  set state(state) {\n    const {\n      compiledMasks,\n      currentMaskRef,\n      currentMask,\n      ...maskedState\n    } = state;\n    this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n    super.state = maskedState;\n  }\n  extractInput(fromPos, toPos, flags) {\n    return this.currentMask ? this.currentMask.extractInput(fromPos, toPos, flags) : '';\n  }\n  extractTail(fromPos, toPos) {\n    return this.currentMask ? this.currentMask.extractTail(fromPos, toPos) : super.extractTail(fromPos, toPos);\n  }\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n  nearestInputPos(cursorPos, direction) {\n    return this.currentMask ? this.currentMask.nearestInputPos(cursorPos, direction) : super.nearestInputPos(cursorPos, direction);\n  }\n\n  // @ts-ignore i don't mind overriding\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : super.overwrite;\n  }\n  set overwrite(overwrite) {\n    console.warn('\"overwrite\" option is not available in dynamic mask, use this option in siblings');\n  }\n\n  // @ts-ignore i don't mind overriding\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : super.eager;\n  }\n  set eager(eager) {\n    console.warn('\"eager\" option is not available in dynamic mask, use this option in siblings');\n  }\n\n  // @ts-ignore i don't mind overriding\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : super.skipInvalid;\n  }\n  set skipInvalid(skipInvalid) {\n    if (this._initialized || skipInvalid !== Masked.DEFAULTS.skipInvalid) {\n      console.warn('\"skipInvalid\" option is not available in dynamic mask, use this option in siblings');\n    }\n  }\n  maskEquals(mask) {\n    return Array.isArray(mask) ? this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const {\n        mask: oldMask,\n        ...restOpts\n      } = mask[mi];\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    }) : super.maskEquals(mask);\n  }\n  typedValueEquals(value) {\n    var _this$currentMask5;\n    return Boolean((_this$currentMask5 = this.currentMask) == null ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n}\nMaskedDynamic.DEFAULTS = void 0;\nMaskedDynamic.DEFAULTS = {\n  dispatch: (appended, masked, flags, tail) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue;\n\n    // simulate input\n    const inputs = masked.compiledMasks.map((m, index) => {\n      const isCurrent = masked.currentMask === m;\n      const startInputPos = isCurrent ? m.value.length : m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT);\n      if (m.rawInputValue !== inputValue) {\n        m.reset();\n        m.append(inputValue, {\n          raw: true\n        });\n      } else if (!isCurrent) {\n        m.remove(startInputPos);\n      }\n      m.append(appended, masked.currentMaskFlags(flags));\n      m.appendTail(tail);\n      return {\n        index,\n        weight: m.rawInputValue.length,\n        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT)))\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\nexport { MaskedDynamic as default };","map":{"version":3,"names":["DIRECTION","objectIncludes","ChangeDetails","createMask","Masked","IMask","MaskedDynamic","constructor","opts","DEFAULTS","currentMask","updateOptions","_update","compiledMasks","Array","isArray","mask","map","m","_appendCharRaw","ch","flags","details","_applyDispatch","aggregate","_appendChar","currentMaskFlags","appended","tail","prevValueBeforeTail","_beforeTailState","_value","value","inputValue","rawInputValue","insertValue","_rawInputValue","tailValue","slice","length","prevMask","prevMaskState","state","doDispatch","reset","d","append","raw","tailShift","inserted","_appendPlaceholder","_appendEager","appendTail","_flags$_beforeTailSta","_flags$_beforeTailSta2","currentMaskRef","dispatch","doValidate","doPrepare","str","s","currentDetails","doPrepareChar","_this$currentMask","forEach","unmaskedValue","typedValue","String","displayValue","isComplete","_this$currentMask2","Boolean","isFilled","_this$currentMask3","remove","fromPos","toPos","_this$currentMask4","maskedState","mi","extractInput","extractTail","doCommit","nearestInputPos","cursorPos","direction","overwrite","console","warn","eager","skipInvalid","_initialized","maskEquals","every","oldMask","restOpts","typedValueEquals","_this$currentMask5","masked","inputs","index","isCurrent","startInputPos","FORCE_LEFT","weight","totalInputPositions","Math","max","sort","i1","i2","default"],"sources":["E:/Faculdade/ADS/PROGRAMAÇÃO FULL STACK Il/Projeto/FrontEnd/saqe/node_modules/imask/esm/masked/dynamic.js"],"sourcesContent":["import { DIRECTION, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\n/** Dynamic mask for choosing appropriate mask in run-time */\nclass MaskedDynamic extends Masked {\n  // TODO types\n  /** Currently chosen mask */\n  /** Compliled {@link Masked} options */\n  // TODO FactoryReturnMasked<?>\n  /** Chooses {@link Masked} depending on input value */\n  constructor(opts) {\n    super({\n      ...MaskedDynamic.DEFAULTS,\n      ...opts\n    });\n    this.currentMask = null;\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    super._update(opts);\n    if ('mask' in opts) {\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => createMask(m)) : [];\n\n      // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const details = this._applyDispatch(ch, flags);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n    return details;\n  }\n  _applyDispatch(appended, flags, tail) {\n    if (appended === void 0) {\n      appended = '';\n    }\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (tail === void 0) {\n      tail = '';\n    }\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask == null ? void 0 : prevMask.state;\n\n    // clone flags to prevent overwriting `_beforeTailState`\n    this.currentMask = this.doDispatch(appended, {\n      ...flags\n    }, tail);\n\n    // restore state after dispatch\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n        if (insertValue) {\n          const d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n        }\n        if (tailValue) {\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n    return details;\n  }\n  _appendPlaceholder() {\n    const details = this._applyDispatch();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n    return details;\n  }\n  _appendEager() {\n    const details = this._applyDispatch();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n    return details;\n  }\n  appendTail(tail) {\n    const details = new ChangeDetails();\n    if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n    return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\n  }\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n    return {\n      ...flags,\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    };\n  }\n  doDispatch(appended, flags, tail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (tail === void 0) {\n      tail = '';\n    }\n    return this.dispatch(appended, this, flags, tail);\n  }\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n  doPrepare(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let [s, details] = super.doPrepare(str, flags);\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepare(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n  doPrepareChar(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let [s, details] = super.doPrepareChar(str, flags);\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepareChar(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n  reset() {\n    var _this$currentMask;\n    (_this$currentMask = this.currentMask) == null ? void 0 : _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n  get value() {\n    return this.currentMask ? this.currentMask.value : '';\n  }\n  set value(value) {\n    super.value = value;\n  }\n  get unmaskedValue() {\n    return this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n  get typedValue() {\n    return this.currentMask ? this.currentMask.typedValue : '';\n  }\n\n  // probably typedValue should not be used with dynamic\n  set typedValue(value) {\n    let unmaskedValue = String(value);\n\n    // double check it\n    if (this.currentMask) {\n      this.currentMask.typedValue = value;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n    this.unmaskedValue = unmaskedValue;\n  }\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n  get isComplete() {\n    var _this$currentMask2;\n    return Boolean((_this$currentMask2 = this.currentMask) == null ? void 0 : _this$currentMask2.isComplete);\n  }\n  get isFilled() {\n    var _this$currentMask3;\n    return Boolean((_this$currentMask3 = this.currentMask) == null ? void 0 : _this$currentMask3.isFilled);\n  }\n  remove(fromPos, toPos) {\n    const details = new ChangeDetails();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(fromPos, toPos))\n      // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n    return details;\n  }\n  get state() {\n    var _this$currentMask4;\n    return {\n      ...super.state,\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) == null ? void 0 : _this$currentMask4.state\n    };\n  }\n  set state(state) {\n    const {\n      compiledMasks,\n      currentMaskRef,\n      currentMask,\n      ...maskedState\n    } = state;\n    this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n    super.state = maskedState;\n  }\n  extractInput(fromPos, toPos, flags) {\n    return this.currentMask ? this.currentMask.extractInput(fromPos, toPos, flags) : '';\n  }\n  extractTail(fromPos, toPos) {\n    return this.currentMask ? this.currentMask.extractTail(fromPos, toPos) : super.extractTail(fromPos, toPos);\n  }\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n  nearestInputPos(cursorPos, direction) {\n    return this.currentMask ? this.currentMask.nearestInputPos(cursorPos, direction) : super.nearestInputPos(cursorPos, direction);\n  }\n\n  // @ts-ignore i don't mind overriding\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : super.overwrite;\n  }\n  set overwrite(overwrite) {\n    console.warn('\"overwrite\" option is not available in dynamic mask, use this option in siblings');\n  }\n\n  // @ts-ignore i don't mind overriding\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : super.eager;\n  }\n  set eager(eager) {\n    console.warn('\"eager\" option is not available in dynamic mask, use this option in siblings');\n  }\n\n  // @ts-ignore i don't mind overriding\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : super.skipInvalid;\n  }\n  set skipInvalid(skipInvalid) {\n    if (this._initialized || skipInvalid !== Masked.DEFAULTS.skipInvalid) {\n      console.warn('\"skipInvalid\" option is not available in dynamic mask, use this option in siblings');\n    }\n  }\n  maskEquals(mask) {\n    return Array.isArray(mask) ? this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const {\n        mask: oldMask,\n        ...restOpts\n      } = mask[mi];\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    }) : super.maskEquals(mask);\n  }\n  typedValueEquals(value) {\n    var _this$currentMask5;\n    return Boolean((_this$currentMask5 = this.currentMask) == null ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n}\nMaskedDynamic.DEFAULTS = void 0;\nMaskedDynamic.DEFAULTS = {\n  dispatch: (appended, masked, flags, tail) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue;\n\n    // simulate input\n    const inputs = masked.compiledMasks.map((m, index) => {\n      const isCurrent = masked.currentMask === m;\n      const startInputPos = isCurrent ? m.value.length : m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT);\n      if (m.rawInputValue !== inputValue) {\n        m.reset();\n        m.append(inputValue, {\n          raw: true\n        });\n      } else if (!isCurrent) {\n        m.remove(startInputPos);\n      }\n      m.append(appended, masked.currentMaskFlags(flags));\n      m.appendTail(tail);\n      return {\n        index,\n        weight: m.rawInputValue.length,\n        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT)))\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\n\nexport { MaskedDynamic as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}