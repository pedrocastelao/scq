{"ast":null,"code":"import { escapeRegExp, DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\n/**\n  Number mask\n*/\nclass MaskedNumber extends Masked {\n  /** Single char */\n\n  /** Single char */\n\n  /** Array of single chars */\n\n  /** */\n\n  /** */\n\n  /** Digits after point */\n\n  /** Flag to remove leading and trailing zeros in the end of editing */\n\n  /** Flag to pad trailing zeros after point in the end of editing */\n\n  constructor(opts) {\n    super({\n      ...MaskedNumber.DEFAULTS,\n      ...opts\n    });\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    super._update(opts);\n    this._updateRegExps();\n  }\n  _updateRegExps() {\n    let start = '^' + (this.allowNegative ? '[+|\\\\-]?' : '');\n    let mid = '\\\\d*';\n    let end = (this.scale ? \"(\" + escapeRegExp(this.radix) + \"\\\\d{0,\" + this.scale + \"})?\" : '') + '$';\n    this._numberRegExp = new RegExp(start + mid + end);\n    this._mapToRadixRegExp = new RegExp(\"[\" + this.mapToRadix.map(escapeRegExp).join('') + \"]\", 'g');\n    this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');\n  }\n  _removeThousandsSeparators(value) {\n    return value.replace(this._thousandsSeparatorRegExp, '');\n  }\n  _insertThousandsSeparators(value) {\n    // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript\n    const parts = value.split(this.radix);\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.thousandsSeparator);\n    return parts.join(this.radix);\n  }\n  doPrepareChar(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    ch = this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (\n    /*\n      radix should be mapped when\n      1) input is done from keyboard = flags.input && flags.raw\n      2) unmasked value is set = !flags.input && !flags.raw\n      and should not be mapped when\n      1) value is set = flags.input && !flags.raw\n      2) raw value is set = !flags.input && flags.raw\n    */\n    flags.input && flags.raw || !flags.input && !flags.raw) ? ch.replace(this._mapToRadixRegExp, this.radix) : ch);\n    const [prepCh, details] = super.doPrepareChar(ch, flags);\n    if (ch && !prepCh) details.skip = true;\n    return [prepCh, details];\n  }\n  _separatorsCount(to, extendOnSeparators) {\n    if (extendOnSeparators === void 0) {\n      extendOnSeparators = false;\n    }\n    let count = 0;\n    for (let pos = 0; pos < to; ++pos) {\n      if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {\n        ++count;\n        if (extendOnSeparators) to += this.thousandsSeparator.length;\n      }\n    }\n    return count;\n  }\n  _separatorsCountFromSlice(slice) {\n    if (slice === void 0) {\n      slice = this._value;\n    }\n    return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);\n  }\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    return this._removeThousandsSeparators(super.extractInput(fromPos, toPos, flags));\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (!this.thousandsSeparator) return super._appendCharRaw(ch, flags);\n    const prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n    const prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);\n    this._value = this._removeThousandsSeparators(this.value);\n    const appendDetails = super._appendCharRaw(ch, flags);\n    this._value = this._insertThousandsSeparators(this._value);\n    const beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);\n    appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;\n    appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;\n    return appendDetails;\n  }\n  _findSeparatorAround(pos) {\n    if (this.thousandsSeparator) {\n      const searchFrom = pos - this.thousandsSeparator.length + 1;\n      const separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);\n      if (separatorPos <= pos) return separatorPos;\n    }\n    return -1;\n  }\n  _adjustRangeWithSeparators(from, to) {\n    const separatorAroundFromPos = this._findSeparatorAround(from);\n    if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;\n    const separatorAroundToPos = this._findSeparatorAround(to);\n    if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;\n    return [from, to];\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    const valueBeforePos = this.value.slice(0, fromPos);\n    const valueAfterPos = this.value.slice(toPos);\n    const prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);\n    this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);\n    return new ChangeDetails({\n      tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length\n    });\n  }\n  nearestInputPos(cursorPos, direction) {\n    if (!this.thousandsSeparator) return cursorPos;\n    switch (direction) {\n      case DIRECTION.NONE:\n      case DIRECTION.LEFT:\n      case DIRECTION.FORCE_LEFT:\n        {\n          const separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);\n          if (separatorAtLeftPos >= 0) {\n            const separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;\n            if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {\n              return separatorAtLeftPos;\n            }\n          }\n          break;\n        }\n      case DIRECTION.RIGHT:\n      case DIRECTION.FORCE_RIGHT:\n        {\n          const separatorAtRightPos = this._findSeparatorAround(cursorPos);\n          if (separatorAtRightPos >= 0) {\n            return separatorAtRightPos + this.thousandsSeparator.length;\n          }\n        }\n    }\n    return cursorPos;\n  }\n  doValidate(flags) {\n    // validate as string\n    let valid = Boolean(this._removeThousandsSeparators(this.value).match(this._numberRegExp));\n    if (valid) {\n      // validate as number\n      const number = this.number;\n      valid = valid && !isNaN(number) && (\n      // check min bound for negative values\n      this.min == null || this.min >= 0 || this.min <= this.number) && (\n      // check max bound for positive values\n      this.max == null || this.max <= 0 || this.number <= this.max);\n    }\n    return valid && super.doValidate(flags);\n  }\n  doCommit() {\n    if (this.value) {\n      const number = this.number;\n      let validnum = number;\n\n      // check bounds\n      if (this.min != null) validnum = Math.max(validnum, this.min);\n      if (this.max != null) validnum = Math.min(validnum, this.max);\n      if (validnum !== number) this.unmaskedValue = this.format(validnum, this);\n      let formatted = this.value;\n      if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);\n      if (this.padFractionalZeros && this.scale > 0) formatted = this._padFractionalZeros(formatted);\n      this._value = formatted;\n    }\n    super.doCommit();\n  }\n  _normalizeZeros(value) {\n    const parts = this._removeThousandsSeparators(value).split(this.radix);\n\n    // remove leading zeros\n    parts[0] = parts[0].replace(/^(\\D*)(0*)(\\d*)/, (match, sign, zeros, num) => sign + num);\n    // add leading zero\n    if (value.length && !/\\d$/.test(parts[0])) parts[0] = parts[0] + '0';\n    if (parts.length > 1) {\n      parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros\n      if (!parts[1].length) parts.length = 1; // remove fractional\n    }\n\n    return this._insertThousandsSeparators(parts.join(this.radix));\n  }\n  _padFractionalZeros(value) {\n    if (!value) return value;\n    const parts = value.split(this.radix);\n    if (parts.length < 2) parts.push('');\n    parts[1] = parts[1].padEnd(this.scale, '0');\n    return parts.join(this.radix);\n  }\n  doSkipInvalid(ch, flags, checkTail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const dropFractional = this.scale === 0 && ch !== this.thousandsSeparator && (ch === this.radix || ch === MaskedNumber.UNMASKED_RADIX || this.mapToRadix.includes(ch));\n    return super.doSkipInvalid(ch, flags, checkTail) && !dropFractional;\n  }\n  get unmaskedValue() {\n    return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, MaskedNumber.UNMASKED_RADIX);\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n  get typedValue() {\n    return this.parse(this.unmaskedValue, this);\n  }\n  set typedValue(n) {\n    this.rawInputValue = this.format(n, this).replace(MaskedNumber.UNMASKED_RADIX, this.radix);\n  }\n\n  /** Parsed Number */\n  get number() {\n    return this.typedValue;\n  }\n  set number(number) {\n    this.typedValue = number;\n  }\n\n  /**\n    Is negative allowed\n  */\n  get allowNegative() {\n    return this.min != null && this.min < 0 || this.max != null && this.max < 0;\n  }\n  typedValueEquals(value) {\n    // handle  0 -> '' case (typed = 0 even if value = '')\n    // for details see https://github.com/uNmAnNeR/imaskjs/issues/134\n    return (super.typedValueEquals(value) || MaskedNumber.EMPTY_VALUES.includes(value) && MaskedNumber.EMPTY_VALUES.includes(this.typedValue)) && !(value === 0 && this.value === '');\n  }\n}\nMaskedNumber.UNMASKED_RADIX = '.';\nMaskedNumber.EMPTY_VALUES = [...Masked.EMPTY_VALUES, 0];\nMaskedNumber.DEFAULTS = {\n  mask: Number,\n  radix: ',',\n  thousandsSeparator: '',\n  mapToRadix: [MaskedNumber.UNMASKED_RADIX],\n  min: Number.MIN_SAFE_INTEGER,\n  max: Number.MAX_SAFE_INTEGER,\n  scale: 2,\n  normalizeZeros: true,\n  padFractionalZeros: false,\n  parse: Number,\n  format: n => n.toLocaleString('en-US', {\n    useGrouping: false,\n    maximumFractionDigits: 20\n  })\n};\nIMask.MaskedNumber = MaskedNumber;\nexport { MaskedNumber as default };","map":{"version":3,"names":["escapeRegExp","DIRECTION","ChangeDetails","Masked","IMask","MaskedNumber","constructor","opts","DEFAULTS","updateOptions","_update","_updateRegExps","start","allowNegative","mid","end","scale","radix","_numberRegExp","RegExp","_mapToRadixRegExp","mapToRadix","map","join","_thousandsSeparatorRegExp","thousandsSeparator","_removeThousandsSeparators","value","replace","_insertThousandsSeparators","parts","split","doPrepareChar","ch","flags","length","input","raw","prepCh","details","skip","_separatorsCount","to","extendOnSeparators","count","pos","_value","indexOf","_separatorsCountFromSlice","slice","extractInput","fromPos","toPos","_adjustRangeWithSeparators","_appendCharRaw","prevBeforeTailValue","tail","_beforeTailState","prevBeforeTailSeparatorsCount","appendDetails","beforeTailValue","beforeTailSeparatorsCount","tailShift","rawInserted","_findSeparatorAround","searchFrom","separatorPos","from","separatorAroundFromPos","separatorAroundToPos","remove","valueBeforePos","valueAfterPos","nearestInputPos","cursorPos","direction","NONE","LEFT","FORCE_LEFT","separatorAtLeftPos","separatorAtLeftEndPos","RIGHT","FORCE_RIGHT","separatorAtRightPos","doValidate","valid","Boolean","match","number","isNaN","min","max","doCommit","validnum","Math","unmaskedValue","format","formatted","normalizeZeros","_normalizeZeros","padFractionalZeros","_padFractionalZeros","sign","zeros","num","test","push","padEnd","doSkipInvalid","checkTail","dropFractional","UNMASKED_RADIX","includes","typedValue","parse","n","rawInputValue","typedValueEquals","EMPTY_VALUES","mask","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","toLocaleString","useGrouping","maximumFractionDigits","default"],"sources":["E:/Faculdade/ADS/PROGRAMAÇÃO FULL STACK Il/Projeto/FrontEnd/saqe/node_modules/imask/esm/masked/number.js"],"sourcesContent":["import { escapeRegExp, DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\n/**\n  Number mask\n*/\nclass MaskedNumber extends Masked {\n  /** Single char */\n\n  /** Single char */\n\n  /** Array of single chars */\n\n  /** */\n\n  /** */\n\n  /** Digits after point */\n\n  /** Flag to remove leading and trailing zeros in the end of editing */\n\n  /** Flag to pad trailing zeros after point in the end of editing */\n\n  constructor(opts) {\n    super({\n      ...MaskedNumber.DEFAULTS,\n      ...opts\n    });\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    super._update(opts);\n    this._updateRegExps();\n  }\n  _updateRegExps() {\n    let start = '^' + (this.allowNegative ? '[+|\\\\-]?' : '');\n    let mid = '\\\\d*';\n    let end = (this.scale ? \"(\" + escapeRegExp(this.radix) + \"\\\\d{0,\" + this.scale + \"})?\" : '') + '$';\n    this._numberRegExp = new RegExp(start + mid + end);\n    this._mapToRadixRegExp = new RegExp(\"[\" + this.mapToRadix.map(escapeRegExp).join('') + \"]\", 'g');\n    this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');\n  }\n  _removeThousandsSeparators(value) {\n    return value.replace(this._thousandsSeparatorRegExp, '');\n  }\n  _insertThousandsSeparators(value) {\n    // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript\n    const parts = value.split(this.radix);\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.thousandsSeparator);\n    return parts.join(this.radix);\n  }\n  doPrepareChar(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    ch = this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (\n    /*\n      radix should be mapped when\n      1) input is done from keyboard = flags.input && flags.raw\n      2) unmasked value is set = !flags.input && !flags.raw\n      and should not be mapped when\n      1) value is set = flags.input && !flags.raw\n      2) raw value is set = !flags.input && flags.raw\n    */\n    flags.input && flags.raw || !flags.input && !flags.raw) ? ch.replace(this._mapToRadixRegExp, this.radix) : ch);\n    const [prepCh, details] = super.doPrepareChar(ch, flags);\n    if (ch && !prepCh) details.skip = true;\n    return [prepCh, details];\n  }\n  _separatorsCount(to, extendOnSeparators) {\n    if (extendOnSeparators === void 0) {\n      extendOnSeparators = false;\n    }\n    let count = 0;\n    for (let pos = 0; pos < to; ++pos) {\n      if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {\n        ++count;\n        if (extendOnSeparators) to += this.thousandsSeparator.length;\n      }\n    }\n    return count;\n  }\n  _separatorsCountFromSlice(slice) {\n    if (slice === void 0) {\n      slice = this._value;\n    }\n    return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);\n  }\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    return this._removeThousandsSeparators(super.extractInput(fromPos, toPos, flags));\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (!this.thousandsSeparator) return super._appendCharRaw(ch, flags);\n    const prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n    const prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);\n    this._value = this._removeThousandsSeparators(this.value);\n    const appendDetails = super._appendCharRaw(ch, flags);\n    this._value = this._insertThousandsSeparators(this._value);\n    const beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);\n    appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;\n    appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;\n    return appendDetails;\n  }\n  _findSeparatorAround(pos) {\n    if (this.thousandsSeparator) {\n      const searchFrom = pos - this.thousandsSeparator.length + 1;\n      const separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);\n      if (separatorPos <= pos) return separatorPos;\n    }\n    return -1;\n  }\n  _adjustRangeWithSeparators(from, to) {\n    const separatorAroundFromPos = this._findSeparatorAround(from);\n    if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;\n    const separatorAroundToPos = this._findSeparatorAround(to);\n    if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;\n    return [from, to];\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    const valueBeforePos = this.value.slice(0, fromPos);\n    const valueAfterPos = this.value.slice(toPos);\n    const prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);\n    this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);\n    return new ChangeDetails({\n      tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length\n    });\n  }\n  nearestInputPos(cursorPos, direction) {\n    if (!this.thousandsSeparator) return cursorPos;\n    switch (direction) {\n      case DIRECTION.NONE:\n      case DIRECTION.LEFT:\n      case DIRECTION.FORCE_LEFT:\n        {\n          const separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);\n          if (separatorAtLeftPos >= 0) {\n            const separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;\n            if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {\n              return separatorAtLeftPos;\n            }\n          }\n          break;\n        }\n      case DIRECTION.RIGHT:\n      case DIRECTION.FORCE_RIGHT:\n        {\n          const separatorAtRightPos = this._findSeparatorAround(cursorPos);\n          if (separatorAtRightPos >= 0) {\n            return separatorAtRightPos + this.thousandsSeparator.length;\n          }\n        }\n    }\n    return cursorPos;\n  }\n  doValidate(flags) {\n    // validate as string\n    let valid = Boolean(this._removeThousandsSeparators(this.value).match(this._numberRegExp));\n    if (valid) {\n      // validate as number\n      const number = this.number;\n      valid = valid && !isNaN(number) && (\n      // check min bound for negative values\n      this.min == null || this.min >= 0 || this.min <= this.number) && (\n      // check max bound for positive values\n      this.max == null || this.max <= 0 || this.number <= this.max);\n    }\n    return valid && super.doValidate(flags);\n  }\n  doCommit() {\n    if (this.value) {\n      const number = this.number;\n      let validnum = number;\n\n      // check bounds\n      if (this.min != null) validnum = Math.max(validnum, this.min);\n      if (this.max != null) validnum = Math.min(validnum, this.max);\n      if (validnum !== number) this.unmaskedValue = this.format(validnum, this);\n      let formatted = this.value;\n      if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);\n      if (this.padFractionalZeros && this.scale > 0) formatted = this._padFractionalZeros(formatted);\n      this._value = formatted;\n    }\n    super.doCommit();\n  }\n  _normalizeZeros(value) {\n    const parts = this._removeThousandsSeparators(value).split(this.radix);\n\n    // remove leading zeros\n    parts[0] = parts[0].replace(/^(\\D*)(0*)(\\d*)/, (match, sign, zeros, num) => sign + num);\n    // add leading zero\n    if (value.length && !/\\d$/.test(parts[0])) parts[0] = parts[0] + '0';\n    if (parts.length > 1) {\n      parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros\n      if (!parts[1].length) parts.length = 1; // remove fractional\n    }\n\n    return this._insertThousandsSeparators(parts.join(this.radix));\n  }\n  _padFractionalZeros(value) {\n    if (!value) return value;\n    const parts = value.split(this.radix);\n    if (parts.length < 2) parts.push('');\n    parts[1] = parts[1].padEnd(this.scale, '0');\n    return parts.join(this.radix);\n  }\n  doSkipInvalid(ch, flags, checkTail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const dropFractional = this.scale === 0 && ch !== this.thousandsSeparator && (ch === this.radix || ch === MaskedNumber.UNMASKED_RADIX || this.mapToRadix.includes(ch));\n    return super.doSkipInvalid(ch, flags, checkTail) && !dropFractional;\n  }\n  get unmaskedValue() {\n    return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, MaskedNumber.UNMASKED_RADIX);\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n  get typedValue() {\n    return this.parse(this.unmaskedValue, this);\n  }\n  set typedValue(n) {\n    this.rawInputValue = this.format(n, this).replace(MaskedNumber.UNMASKED_RADIX, this.radix);\n  }\n\n  /** Parsed Number */\n  get number() {\n    return this.typedValue;\n  }\n  set number(number) {\n    this.typedValue = number;\n  }\n\n  /**\n    Is negative allowed\n  */\n  get allowNegative() {\n    return this.min != null && this.min < 0 || this.max != null && this.max < 0;\n  }\n  typedValueEquals(value) {\n    // handle  0 -> '' case (typed = 0 even if value = '')\n    // for details see https://github.com/uNmAnNeR/imaskjs/issues/134\n    return (super.typedValueEquals(value) || MaskedNumber.EMPTY_VALUES.includes(value) && MaskedNumber.EMPTY_VALUES.includes(this.typedValue)) && !(value === 0 && this.value === '');\n  }\n}\nMaskedNumber.UNMASKED_RADIX = '.';\nMaskedNumber.EMPTY_VALUES = [...Masked.EMPTY_VALUES, 0];\nMaskedNumber.DEFAULTS = {\n  mask: Number,\n  radix: ',',\n  thousandsSeparator: '',\n  mapToRadix: [MaskedNumber.UNMASKED_RADIX],\n  min: Number.MIN_SAFE_INTEGER,\n  max: Number.MAX_SAFE_INTEGER,\n  scale: 2,\n  normalizeZeros: true,\n  padFractionalZeros: false,\n  parse: Number,\n  format: n => n.toLocaleString('en-US', {\n    useGrouping: false,\n    maximumFractionDigits: 20\n  })\n};\nIMask.MaskedNumber = MaskedNumber;\n\nexport { MaskedNumber as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}