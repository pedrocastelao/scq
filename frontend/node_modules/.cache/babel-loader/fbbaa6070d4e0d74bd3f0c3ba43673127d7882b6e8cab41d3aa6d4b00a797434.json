{"ast":null,"code":"import ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, DIRECTION, forceDirection } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n\n/** Append flags */\n\n/** Extract flags */\n\n// see https://github.com/microsoft/TypeScript/issues/6223\n\n/** Provides common masking stuff */\nclass Masked {\n  /** @type {Mask} */\n\n  /** */\n\n  /** Transforms value before mask processing */\n\n  /** Transforms each char before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing at the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse strgin to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  constructor(opts) {\n    this._value = '';\n    this._update({\n      ...Masked.DEFAULTS,\n      ...opts\n    });\n    this._initialized = true;\n  }\n\n  /** Sets and applies new options */\n  updateOptions(opts) {\n    if (!Object.keys(opts).length) return;\n    this.withValueRefresh(this._update.bind(this, opts));\n  }\n\n  /** Sets new options */\n  _update(opts) {\n    Object.assign(this, opts);\n  }\n\n  /** Mask state */\n  get state() {\n    return {\n      _value: this.value\n    };\n  }\n  set state(state) {\n    this._value = state._value;\n  }\n\n  /** Resets value */\n  reset() {\n    this._value = '';\n  }\n  get value() {\n    return this._value;\n  }\n  set value(value) {\n    this.resolve(value, {\n      input: true\n    });\n  }\n\n  /** Resolve new value */\n  resolve(value, flags) {\n    if (flags === void 0) {\n      flags = {\n        input: true\n      };\n    }\n    this.reset();\n    this.append(value, flags, '');\n    this.doCommit();\n  }\n  get unmaskedValue() {\n    return this.value;\n  }\n  set unmaskedValue(value) {\n    this.resolve(value, {});\n  }\n  get typedValue() {\n    return this.parse ? this.parse(this.value, this) : this.unmaskedValue;\n  }\n  set typedValue(value) {\n    if (this.format) {\n      this.value = this.format(value, this);\n    } else {\n      this.unmaskedValue = String(value);\n    }\n  }\n\n  /** Value that includes raw user input */\n  get rawInputValue() {\n    return this.extractInput(0, this.value.length, {\n      raw: true\n    });\n  }\n  set rawInputValue(value) {\n    this.resolve(value, {\n      raw: true\n    });\n  }\n  get displayValue() {\n    return this.value;\n  }\n  get isComplete() {\n    return true;\n  }\n  get isFilled() {\n    return this.isComplete;\n  }\n\n  /** Finds nearest input position in direction */\n  nearestInputPos(cursorPos, direction) {\n    return cursorPos;\n  }\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    return Math.min(this.value.length, toPos - fromPos);\n  }\n\n  /** Extracts value in range considering flags */\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    return this.value.slice(fromPos, toPos);\n  }\n\n  /** Extracts tail in range */\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n  }\n\n  /** Appends tail */\n  appendTail(tail) {\n    if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n    return tail.appendTo(this);\n  }\n\n  /** Appends char */\n  _appendCharRaw(ch, flags) {\n    if (!ch) return new ChangeDetails();\n    this._value += ch;\n    return new ChangeDetails({\n      inserted: ch,\n      rawInserted: ch\n    });\n  }\n\n  /** Appends char */\n  _appendChar(ch, flags, checkTail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const consistentState = this.state;\n    let details;\n    [ch, details] = this.doPrepareChar(ch, flags);\n    details = details.aggregate(this._appendCharRaw(ch, flags));\n    if (details.inserted) {\n      let consistentTail;\n      let appended = this.doValidate(flags) !== false;\n      if (appended && checkTail != null) {\n        // validation ok, check tail\n        const beforeTailState = this.state;\n        if (this.overwrite === true) {\n          consistentTail = checkTail.state;\n          checkTail.unshift(this.value.length - details.tailShift);\n        }\n        let tailDetails = this.appendTail(checkTail);\n        appended = tailDetails.rawInserted === checkTail.toString();\n\n        // not ok, try shift\n        if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n          this.state = beforeTailState;\n          consistentTail = checkTail.state;\n          checkTail.shift();\n          tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString();\n        }\n\n        // if ok, rollback state after tail\n        if (appended && tailDetails.inserted) this.state = beforeTailState;\n      }\n\n      // revert all if something went wrong\n      if (!appended) {\n        details = new ChangeDetails();\n        this.state = consistentState;\n        if (checkTail && consistentTail) checkTail.state = consistentTail;\n      }\n    }\n    return details;\n  }\n\n  /** Appends optional placeholder at the end */\n  _appendPlaceholder() {\n    return new ChangeDetails();\n  }\n\n  /** Appends optional eager placeholder at the end */\n  _appendEager() {\n    return new ChangeDetails();\n  }\n\n  /** Appends symbols considering flags */\n  append(str, flags, tail) {\n    if (!isString(str)) throw new Error('value should be string');\n    const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n    if (flags != null && flags.tail) flags._beforeTailState = this.state;\n    let details;\n    [str, details] = this.doPrepare(str, flags);\n    for (let ci = 0; ci < str.length; ++ci) {\n      const d = this._appendChar(str[ci], flags, checkTail);\n      if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;\n      details.aggregate(d);\n    }\n\n    // append tail but aggregate only tailShift\n    if (checkTail != null) {\n      details.tailShift += this.appendTail(checkTail).tailShift;\n      // TODO it's a good idea to clear state after appending ends\n      // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n      // this._resetBeforeTailState();\n    }\n\n    if ((this.eager === true || this.eager === 'append') && flags != null && flags.input && str) {\n      details.aggregate(this._appendEager());\n    }\n    return details;\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n    return new ChangeDetails();\n  }\n\n  /** Calls function and reapplies current value */\n  withValueRefresh(fn) {\n    if (this._refreshing || !this._initialized) return fn();\n    this._refreshing = true;\n    const rawInput = this.rawInputValue;\n    const value = this.value;\n    const ret = fn();\n    this.rawInputValue = rawInput;\n    // append lost trailing chars at the end\n    if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n      this.append(value.slice(this.value.length), {}, '');\n    }\n    delete this._refreshing;\n    return ret;\n  }\n  runIsolated(fn) {\n    if (this._isolated || !this._initialized) return fn(this);\n    this._isolated = true;\n    const state = this.state;\n    const ret = fn(this);\n    this.state = state;\n    delete this._isolated;\n    return ret;\n  }\n  doSkipInvalid(ch, flags, checkTail) {\n    return Boolean(this.skipInvalid);\n  }\n\n  /** Prepares string before mask processing */\n  doPrepare(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    return ChangeDetails.normalize(this.prepare ? this.prepare(str, this, flags) : str);\n  }\n\n  /** Prepares each char before mask processing */\n  doPrepareChar(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    return ChangeDetails.normalize(this.prepareChar ? this.prepareChar(str, this, flags) : str);\n  }\n\n  /** Validates if value is acceptable */\n  doValidate(flags) {\n    return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n  }\n\n  /** Does additional processing at the end of editing */\n  doCommit() {\n    if (this.commit) this.commit(this.value, this);\n  }\n  splice(start, deleteCount, inserted, removeDirection, flags) {\n    if (removeDirection === void 0) {\n      removeDirection = DIRECTION.NONE;\n    }\n    if (flags === void 0) {\n      flags = {\n        input: true\n      };\n    }\n    const tailPos = start + deleteCount;\n    const tail = this.extractTail(tailPos);\n    const eagerRemove = this.eager === true || this.eager === 'remove';\n    let oldRawValue;\n    if (eagerRemove) {\n      removeDirection = forceDirection(removeDirection);\n      oldRawValue = this.extractInput(0, tailPos, {\n        raw: true\n      });\n    }\n    let startChangePos = start;\n    const details = new ChangeDetails();\n\n    // if it is just deletion without insertion\n    if (removeDirection !== DIRECTION.NONE) {\n      startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection);\n\n      // adjust tailShift if start was aligned\n      details.tailShift = startChangePos - start;\n    }\n    details.aggregate(this.remove(startChangePos));\n    if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n      if (removeDirection === DIRECTION.FORCE_LEFT) {\n        let valLength;\n        while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {\n          details.aggregate(new ChangeDetails({\n            tailShift: -1\n          })).aggregate(this.remove(valLength - 1));\n        }\n      } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n        tail.unshift();\n      }\n    }\n    return details.aggregate(this.append(inserted, flags, tail));\n  }\n  maskEquals(mask) {\n    return this.mask === mask;\n  }\n  typedValueEquals(value) {\n    const tval = this.typedValue;\n    return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || this.format && this.format(value, this) === this.format(this.typedValue, this);\n  }\n}\nMasked.DEFAULTS = {\n  skipInvalid: true\n};\nMasked.EMPTY_VALUES = [undefined, null, ''];\nIMask.Masked = Masked;\nexport { Masked as default };","map":{"version":3,"names":["ChangeDetails","ContinuousTailDetails","isString","DIRECTION","forceDirection","IMask","Masked","constructor","opts","_value","_update","DEFAULTS","_initialized","updateOptions","Object","keys","length","withValueRefresh","bind","assign","state","value","reset","resolve","input","flags","append","doCommit","unmaskedValue","typedValue","parse","format","String","rawInputValue","extractInput","raw","displayValue","isComplete","isFilled","nearestInputPos","cursorPos","direction","totalInputPositions","fromPos","toPos","Math","min","slice","extractTail","appendTail","tail","appendTo","_appendCharRaw","ch","inserted","rawInserted","_appendChar","checkTail","consistentState","details","doPrepareChar","aggregate","consistentTail","appended","doValidate","beforeTailState","overwrite","unshift","tailShift","tailDetails","toString","shift","_appendPlaceholder","_appendEager","str","Error","_beforeTailState","doPrepare","ci","d","doSkipInvalid","eager","remove","fn","_refreshing","rawInput","ret","indexOf","runIsolated","_isolated","Boolean","skipInvalid","normalize","prepare","prepareChar","validate","parent","commit","splice","start","deleteCount","removeDirection","NONE","tailPos","eagerRemove","oldRawValue","startChangePos","FORCE_LEFT","valLength","FORCE_RIGHT","maskEquals","mask","typedValueEquals","tval","EMPTY_VALUES","includes","undefined","default"],"sources":["E:/Faculdade/ADS/PROGRAMAÇÃO FULL STACK Il/Projeto/FrontEnd/saqe/node_modules/imask/esm/masked/base.js"],"sourcesContent":["import ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, DIRECTION, forceDirection } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n\n/** Append flags */\n\n/** Extract flags */\n\n// see https://github.com/microsoft/TypeScript/issues/6223\n\n/** Provides common masking stuff */\nclass Masked {\n  /** @type {Mask} */\n\n  /** */\n\n  /** Transforms value before mask processing */\n\n  /** Transforms each char before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing at the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse strgin to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  constructor(opts) {\n    this._value = '';\n    this._update({\n      ...Masked.DEFAULTS,\n      ...opts\n    });\n    this._initialized = true;\n  }\n\n  /** Sets and applies new options */\n  updateOptions(opts) {\n    if (!Object.keys(opts).length) return;\n    this.withValueRefresh(this._update.bind(this, opts));\n  }\n\n  /** Sets new options */\n  _update(opts) {\n    Object.assign(this, opts);\n  }\n\n  /** Mask state */\n  get state() {\n    return {\n      _value: this.value\n    };\n  }\n  set state(state) {\n    this._value = state._value;\n  }\n\n  /** Resets value */\n  reset() {\n    this._value = '';\n  }\n  get value() {\n    return this._value;\n  }\n  set value(value) {\n    this.resolve(value, {\n      input: true\n    });\n  }\n\n  /** Resolve new value */\n  resolve(value, flags) {\n    if (flags === void 0) {\n      flags = {\n        input: true\n      };\n    }\n    this.reset();\n    this.append(value, flags, '');\n    this.doCommit();\n  }\n  get unmaskedValue() {\n    return this.value;\n  }\n  set unmaskedValue(value) {\n    this.resolve(value, {});\n  }\n  get typedValue() {\n    return this.parse ? this.parse(this.value, this) : this.unmaskedValue;\n  }\n  set typedValue(value) {\n    if (this.format) {\n      this.value = this.format(value, this);\n    } else {\n      this.unmaskedValue = String(value);\n    }\n  }\n\n  /** Value that includes raw user input */\n  get rawInputValue() {\n    return this.extractInput(0, this.value.length, {\n      raw: true\n    });\n  }\n  set rawInputValue(value) {\n    this.resolve(value, {\n      raw: true\n    });\n  }\n  get displayValue() {\n    return this.value;\n  }\n  get isComplete() {\n    return true;\n  }\n  get isFilled() {\n    return this.isComplete;\n  }\n\n  /** Finds nearest input position in direction */\n  nearestInputPos(cursorPos, direction) {\n    return cursorPos;\n  }\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    return Math.min(this.value.length, toPos - fromPos);\n  }\n\n  /** Extracts value in range considering flags */\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    return this.value.slice(fromPos, toPos);\n  }\n\n  /** Extracts tail in range */\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n  }\n\n  /** Appends tail */\n  appendTail(tail) {\n    if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n    return tail.appendTo(this);\n  }\n\n  /** Appends char */\n  _appendCharRaw(ch, flags) {\n    if (!ch) return new ChangeDetails();\n    this._value += ch;\n    return new ChangeDetails({\n      inserted: ch,\n      rawInserted: ch\n    });\n  }\n\n  /** Appends char */\n  _appendChar(ch, flags, checkTail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const consistentState = this.state;\n    let details;\n    [ch, details] = this.doPrepareChar(ch, flags);\n    details = details.aggregate(this._appendCharRaw(ch, flags));\n    if (details.inserted) {\n      let consistentTail;\n      let appended = this.doValidate(flags) !== false;\n      if (appended && checkTail != null) {\n        // validation ok, check tail\n        const beforeTailState = this.state;\n        if (this.overwrite === true) {\n          consistentTail = checkTail.state;\n          checkTail.unshift(this.value.length - details.tailShift);\n        }\n        let tailDetails = this.appendTail(checkTail);\n        appended = tailDetails.rawInserted === checkTail.toString();\n\n        // not ok, try shift\n        if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n          this.state = beforeTailState;\n          consistentTail = checkTail.state;\n          checkTail.shift();\n          tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString();\n        }\n\n        // if ok, rollback state after tail\n        if (appended && tailDetails.inserted) this.state = beforeTailState;\n      }\n\n      // revert all if something went wrong\n      if (!appended) {\n        details = new ChangeDetails();\n        this.state = consistentState;\n        if (checkTail && consistentTail) checkTail.state = consistentTail;\n      }\n    }\n    return details;\n  }\n\n  /** Appends optional placeholder at the end */\n  _appendPlaceholder() {\n    return new ChangeDetails();\n  }\n\n  /** Appends optional eager placeholder at the end */\n  _appendEager() {\n    return new ChangeDetails();\n  }\n\n  /** Appends symbols considering flags */\n  append(str, flags, tail) {\n    if (!isString(str)) throw new Error('value should be string');\n    const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n    if (flags != null && flags.tail) flags._beforeTailState = this.state;\n    let details;\n    [str, details] = this.doPrepare(str, flags);\n    for (let ci = 0; ci < str.length; ++ci) {\n      const d = this._appendChar(str[ci], flags, checkTail);\n      if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;\n      details.aggregate(d);\n    }\n\n    // append tail but aggregate only tailShift\n    if (checkTail != null) {\n      details.tailShift += this.appendTail(checkTail).tailShift;\n      // TODO it's a good idea to clear state after appending ends\n      // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n      // this._resetBeforeTailState();\n    }\n\n    if ((this.eager === true || this.eager === 'append') && flags != null && flags.input && str) {\n      details.aggregate(this._appendEager());\n    }\n    return details;\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n    return new ChangeDetails();\n  }\n\n  /** Calls function and reapplies current value */\n  withValueRefresh(fn) {\n    if (this._refreshing || !this._initialized) return fn();\n    this._refreshing = true;\n    const rawInput = this.rawInputValue;\n    const value = this.value;\n    const ret = fn();\n    this.rawInputValue = rawInput;\n    // append lost trailing chars at the end\n    if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n      this.append(value.slice(this.value.length), {}, '');\n    }\n    delete this._refreshing;\n    return ret;\n  }\n  runIsolated(fn) {\n    if (this._isolated || !this._initialized) return fn(this);\n    this._isolated = true;\n    const state = this.state;\n    const ret = fn(this);\n    this.state = state;\n    delete this._isolated;\n    return ret;\n  }\n  doSkipInvalid(ch, flags, checkTail) {\n    return Boolean(this.skipInvalid);\n  }\n\n  /** Prepares string before mask processing */\n  doPrepare(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    return ChangeDetails.normalize(this.prepare ? this.prepare(str, this, flags) : str);\n  }\n\n  /** Prepares each char before mask processing */\n  doPrepareChar(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    return ChangeDetails.normalize(this.prepareChar ? this.prepareChar(str, this, flags) : str);\n  }\n\n  /** Validates if value is acceptable */\n  doValidate(flags) {\n    return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n  }\n\n  /** Does additional processing at the end of editing */\n  doCommit() {\n    if (this.commit) this.commit(this.value, this);\n  }\n  splice(start, deleteCount, inserted, removeDirection, flags) {\n    if (removeDirection === void 0) {\n      removeDirection = DIRECTION.NONE;\n    }\n    if (flags === void 0) {\n      flags = {\n        input: true\n      };\n    }\n    const tailPos = start + deleteCount;\n    const tail = this.extractTail(tailPos);\n    const eagerRemove = this.eager === true || this.eager === 'remove';\n    let oldRawValue;\n    if (eagerRemove) {\n      removeDirection = forceDirection(removeDirection);\n      oldRawValue = this.extractInput(0, tailPos, {\n        raw: true\n      });\n    }\n    let startChangePos = start;\n    const details = new ChangeDetails();\n\n    // if it is just deletion without insertion\n    if (removeDirection !== DIRECTION.NONE) {\n      startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection);\n\n      // adjust tailShift if start was aligned\n      details.tailShift = startChangePos - start;\n    }\n    details.aggregate(this.remove(startChangePos));\n    if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n      if (removeDirection === DIRECTION.FORCE_LEFT) {\n        let valLength;\n        while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {\n          details.aggregate(new ChangeDetails({\n            tailShift: -1\n          })).aggregate(this.remove(valLength - 1));\n        }\n      } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n        tail.unshift();\n      }\n    }\n    return details.aggregate(this.append(inserted, flags, tail));\n  }\n  maskEquals(mask) {\n    return this.mask === mask;\n  }\n  typedValueEquals(value) {\n    const tval = this.typedValue;\n    return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || this.format && this.format(value, this) === this.format(this.typedValue, this);\n  }\n}\nMasked.DEFAULTS = {\n  skipInvalid: true\n};\nMasked.EMPTY_VALUES = [undefined, null, ''];\nIMask.Masked = Masked;\n\nexport { Masked as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}