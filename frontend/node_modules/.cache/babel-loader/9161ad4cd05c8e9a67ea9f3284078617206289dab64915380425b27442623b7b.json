{"ast":null,"code":"import IMask from '../core/holder.js';\nimport MaskedPattern from './pattern.js';\nimport '../core/change-details.js';\nimport '../core/utils.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './factory.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/input-definition.js';\nimport './regexp.js';\n\n/** Pattern which accepts ranges */\nclass MaskedRange extends MaskedPattern {\n  /**\n    Optionally sets max length of pattern.\n    Used when pattern length is longer then `to` param length. Pads zeros at start in this case.\n  */\n\n  /** Min bound */\n\n  /** Max bound */\n\n  /** */\n\n  get _matchFrom() {\n    return this.maxLength - String(this.from).length;\n  }\n  constructor(opts) {\n    super(opts); // mask will be created in _update\n  }\n\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    const {\n      to = this.to || 0,\n      from = this.from || 0,\n      maxLength = this.maxLength || 0,\n      autofix = this.autofix,\n      ...patternOpts\n    } = opts;\n    this.to = to;\n    this.from = from;\n    this.maxLength = Math.max(String(to).length, maxLength);\n    this.autofix = autofix;\n    const fromStr = String(this.from).padStart(this.maxLength, '0');\n    const toStr = String(this.to).padStart(this.maxLength, '0');\n    let sameCharsCount = 0;\n    while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) ++sameCharsCount;\n    patternOpts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, '\\\\0') + '0'.repeat(this.maxLength - sameCharsCount);\n    super._update(patternOpts);\n  }\n  get isComplete() {\n    return super.isComplete && Boolean(this.value);\n  }\n  boundaries(str) {\n    let minstr = '';\n    let maxstr = '';\n    const [, placeholder, num] = str.match(/^(\\D*)(\\d*)(\\D*)/) || [];\n    if (num) {\n      minstr = '0'.repeat(placeholder.length) + num;\n      maxstr = '9'.repeat(placeholder.length) + num;\n    }\n    minstr = minstr.padEnd(this.maxLength, '0');\n    maxstr = maxstr.padEnd(this.maxLength, '9');\n    return [minstr, maxstr];\n  }\n  doPrepareChar(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let details;\n    [ch, details] = super.doPrepareChar(ch.replace(/\\D/g, ''), flags);\n    if (!this.autofix || !ch) return [ch, details];\n    const fromStr = String(this.from).padStart(this.maxLength, '0');\n    const toStr = String(this.to).padStart(this.maxLength, '0');\n    let nextVal = this.value + ch;\n    if (nextVal.length > this.maxLength) return ['', details];\n    const [minstr, maxstr] = this.boundaries(nextVal);\n    if (Number(maxstr) < this.from) return [fromStr[nextVal.length - 1], details];\n    if (Number(minstr) > this.to) {\n      if (this.autofix === 'pad' && nextVal.length < this.maxLength) {\n        return ['', details.aggregate(this.append(fromStr[nextVal.length - 1] + ch, flags))];\n      }\n      return [toStr[nextVal.length - 1], details];\n    }\n    return [ch, details];\n  }\n  doValidate(flags) {\n    const str = this.value;\n    const firstNonZero = str.search(/[^0]/);\n    if (firstNonZero === -1 && str.length <= this._matchFrom) return true;\n    const [minstr, maxstr] = this.boundaries(str);\n    return this.from <= Number(maxstr) && Number(minstr) <= this.to && super.doValidate(flags);\n  }\n}\nIMask.MaskedRange = MaskedRange;\nexport { MaskedRange as default };","map":{"version":3,"names":["IMask","MaskedPattern","MaskedRange","_matchFrom","maxLength","String","from","length","constructor","opts","updateOptions","_update","to","autofix","patternOpts","Math","max","fromStr","padStart","toStr","sameCharsCount","mask","slice","replace","repeat","isComplete","Boolean","value","boundaries","str","minstr","maxstr","placeholder","num","match","padEnd","doPrepareChar","ch","flags","details","nextVal","Number","aggregate","append","doValidate","firstNonZero","search","default"],"sources":["E:/Faculdade/ADS/PROGRAMAÇÃO FULL STACK Il/Projeto/FrontEnd/saqe/node_modules/imask/esm/masked/range.js"],"sourcesContent":["import IMask from '../core/holder.js';\nimport MaskedPattern from './pattern.js';\nimport '../core/change-details.js';\nimport '../core/utils.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './factory.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/input-definition.js';\nimport './regexp.js';\n\n/** Pattern which accepts ranges */\nclass MaskedRange extends MaskedPattern {\n  /**\n    Optionally sets max length of pattern.\n    Used when pattern length is longer then `to` param length. Pads zeros at start in this case.\n  */\n\n  /** Min bound */\n\n  /** Max bound */\n\n  /** */\n\n  get _matchFrom() {\n    return this.maxLength - String(this.from).length;\n  }\n  constructor(opts) {\n    super(opts); // mask will be created in _update\n  }\n\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    const {\n      to = this.to || 0,\n      from = this.from || 0,\n      maxLength = this.maxLength || 0,\n      autofix = this.autofix,\n      ...patternOpts\n    } = opts;\n    this.to = to;\n    this.from = from;\n    this.maxLength = Math.max(String(to).length, maxLength);\n    this.autofix = autofix;\n    const fromStr = String(this.from).padStart(this.maxLength, '0');\n    const toStr = String(this.to).padStart(this.maxLength, '0');\n    let sameCharsCount = 0;\n    while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) ++sameCharsCount;\n    patternOpts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, '\\\\0') + '0'.repeat(this.maxLength - sameCharsCount);\n    super._update(patternOpts);\n  }\n  get isComplete() {\n    return super.isComplete && Boolean(this.value);\n  }\n  boundaries(str) {\n    let minstr = '';\n    let maxstr = '';\n    const [, placeholder, num] = str.match(/^(\\D*)(\\d*)(\\D*)/) || [];\n    if (num) {\n      minstr = '0'.repeat(placeholder.length) + num;\n      maxstr = '9'.repeat(placeholder.length) + num;\n    }\n    minstr = minstr.padEnd(this.maxLength, '0');\n    maxstr = maxstr.padEnd(this.maxLength, '9');\n    return [minstr, maxstr];\n  }\n  doPrepareChar(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let details;\n    [ch, details] = super.doPrepareChar(ch.replace(/\\D/g, ''), flags);\n    if (!this.autofix || !ch) return [ch, details];\n    const fromStr = String(this.from).padStart(this.maxLength, '0');\n    const toStr = String(this.to).padStart(this.maxLength, '0');\n    let nextVal = this.value + ch;\n    if (nextVal.length > this.maxLength) return ['', details];\n    const [minstr, maxstr] = this.boundaries(nextVal);\n    if (Number(maxstr) < this.from) return [fromStr[nextVal.length - 1], details];\n    if (Number(minstr) > this.to) {\n      if (this.autofix === 'pad' && nextVal.length < this.maxLength) {\n        return ['', details.aggregate(this.append(fromStr[nextVal.length - 1] + ch, flags))];\n      }\n      return [toStr[nextVal.length - 1], details];\n    }\n    return [ch, details];\n  }\n  doValidate(flags) {\n    const str = this.value;\n    const firstNonZero = str.search(/[^0]/);\n    if (firstNonZero === -1 && str.length <= this._matchFrom) return true;\n    const [minstr, maxstr] = this.boundaries(str);\n    return this.from <= Number(maxstr) && Number(minstr) <= this.to && super.doValidate(flags);\n  }\n}\nIMask.MaskedRange = MaskedRange;\n\nexport { MaskedRange as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}