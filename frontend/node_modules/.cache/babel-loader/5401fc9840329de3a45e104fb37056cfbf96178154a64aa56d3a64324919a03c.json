{"ast":null,"code":"import ChangeDetails from '../core/change-details.js';\nimport IMask from '../core/holder.js';\nimport { DIRECTION } from '../core/utils.js';\nimport Masked from './base.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport PatternInputDefinition from './pattern/input-definition.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\n/**\n  Pattern mask\n*/\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n\n  constructor(opts) {\n    super({\n      ...MaskedPattern.DEFAULTS,\n      ...opts,\n      definitions: Object.assign({}, PatternInputDefinition.DEFAULT_DEFINITIONS, opts == null ? void 0 : opts.definitions)\n    });\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n    super._update(opts);\n    this._rebuildMask();\n  }\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this._stops = [];\n    this._maskedBlocks = {};\n    let pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n    for (let i = 0; i < pattern.length; ++i) {\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n        // order by key length\n        bNames.sort((a, b) => b.length - a.length);\n        // use block name with max length\n        const bName = bNames[0];\n        if (bName) {\n          const maskedBlock = createMask({\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite,\n            ...normalizeOpts(this.blocks[bName]),\n            parent: this\n          });\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n\n            // store block index\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n          i += bName.length - 1;\n          continue;\n        }\n      }\n      let char = pattern[i];\n      let isInput = (char in defs);\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n        continue;\n      }\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n      const def = isInput ? new PatternInputDefinition({\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar,\n        ...normalizeOpts(defs[char]),\n        parent: this\n      }) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n      this._blocks.push(def);\n    }\n  }\n  get state() {\n    return {\n      ...super.state,\n      _blocks: this._blocks.map(b => b.state)\n    };\n  }\n  set state(state) {\n    const {\n      _blocks,\n      ...maskedState\n    } = state;\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n    super.state = maskedState;\n  }\n  reset() {\n    super.reset();\n    this._blocks.forEach(b => b.reset());\n  }\n  get isComplete() {\n    return this._blocks.every(b => b.isComplete);\n  }\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n    super.doCommit();\n  }\n  get unmaskedValue() {\n    return this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n  get value() {\n    // TODO return _value when not in change?\n    return this._blocks.reduce((str, b) => str += b.value, '');\n  }\n  set value(value) {\n    super.value = value;\n  }\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n  _appendEager() {\n    var _this$_mapPosToBlock;\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) == null ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details;\n\n    // TODO test if it works for nested pattern masks\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n    return details;\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const blockIter = this._mapPosToBlock(this.value.length);\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n      const block = this._blocks[bi];\n      if (!block) break;\n      const blockDetails = block._appendChar(ch, {\n        ...flags,\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta2[bi]\n      });\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n    return chunkTail;\n  }\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (fromPos === toPos) return '';\n    let input = '';\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n    return input;\n  }\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n    return stopBefore;\n  }\n\n  /** Appends placeholder depending on laziness */\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n    const startBlockIter = this._mapPosToBlock(this.value.length);\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        var _blocks2;\n        const bDetails = b._appendPlaceholder((_blocks2 = b._blocks) == null ? void 0 : _blocks2.length);\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n    return details;\n  }\n\n  /** Finds block in pos */\n  _mapPosToBlock(pos) {\n    let accVal = '';\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.value;\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.value.length, 0);\n  }\n  _forEachBlocksInRange(fromPos, toPos, fn) {\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos);\n      // process first block\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n        }\n\n        // process last block\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    const removeDetails = super.remove(fromPos, toPos);\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n    return removeDetails;\n  }\n  nearestInputPos(cursorPos, direction) {\n    if (direction === void 0) {\n      direction = DIRECTION.NONE;\n    }\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.value.length;\n    }\n\n    // FORCE is only about a|* otherwise is 0\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      }\n\n      // forward flow\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled();\n\n      // backward flow\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n\n      // cursor.popState();\n      // if (\n      //   cursor.pushRightBeforeInput() &&\n      //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n      //   (!this.lazy || this.extractInput())\n      // ) return cursor.pos;\n\n      return 0;\n    }\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.value.length;\n\n      // backward flow\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n    return cursorPos;\n  }\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    let total = 0;\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      total += b.totalInputPositions(bFromPos, bToPos);\n    });\n    return total;\n  }\n\n  /** Get block by name */\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n\n  /** Get all blocks by name */\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n}\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\nexport { MaskedPattern as default };","map":{"version":3,"names":["ChangeDetails","IMask","DIRECTION","Masked","createMask","normalizeOpts","ChunksTailDetails","PatternCursor","PatternFixedDefinition","PatternInputDefinition","MaskedPattern","constructor","opts","DEFAULTS","definitions","Object","assign","DEFAULT_DEFINITIONS","updateOptions","_update","_rebuildMask","defs","_blocks","_stops","_maskedBlocks","pattern","mask","unmaskingBlock","optionalBlock","i","length","blocks","p","slice","bNames","keys","filter","bName","indexOf","sort","a","b","maskedBlock","lazy","eager","placeholderChar","displayChar","overwrite","parent","push","char","isInput","STOP_CHAR","ESCAPE_CHAR","def","isOptional","isUnmasking","state","map","maskedState","forEach","bi","reset","isComplete","every","isFilled","isFixed","doCommit","unmaskedValue","reduce","str","value","displayValue","appendTail","tail","aggregate","_appendPlaceholder","_appendEager","_this$_mapPosToBlock","details","startBlockIndex","_mapPosToBlock","index","d","inserted","_appendCharRaw","ch","flags","blockIter","_flags$_beforeTailSta","_flags$_beforeTailSta2","block","blockDetails","_appendChar","_beforeTailState","skip","rawInserted","extractTail","fromPos","toPos","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","stop","_findStopBefore","from","_blockStartPos","blockIndex","extend","extractInput","input","_","stopBefore","si","toBlockIndex","startBlockIter","endBlockIndex","_blocks2","bDetails","_value","pos","accVal","blockStartPos","offset","fn","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","remove","removeDetails","nearestInputPos","cursorPos","direction","NONE","cursor","pushRightBeforeInput","popState","pushLeftBeforeInput","LEFT","FORCE_LEFT","pushRightBeforeFilled","ok","pushLeftBeforeRequired","pushLeftBeforeFilled","pushRightBeforeRequired","RIGHT","FORCE_RIGHT","totalInputPositions","total","name","maskedBlocks","indices","gi","InputDefinition","FixedDefinition","default"],"sources":["E:/Faculdade/ADS/PROGRAMAÇÃO FULL STACK Il/Projeto/FrontEnd/saqe/node_modules/imask/esm/masked/pattern.js"],"sourcesContent":["import ChangeDetails from '../core/change-details.js';\nimport IMask from '../core/holder.js';\nimport { DIRECTION } from '../core/utils.js';\nimport Masked from './base.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport PatternInputDefinition from './pattern/input-definition.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\n/**\n  Pattern mask\n*/\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n\n  constructor(opts) {\n    super({\n      ...MaskedPattern.DEFAULTS,\n      ...opts,\n      definitions: Object.assign({}, PatternInputDefinition.DEFAULT_DEFINITIONS, opts == null ? void 0 : opts.definitions)\n    });\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n    super._update(opts);\n    this._rebuildMask();\n  }\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this._stops = [];\n    this._maskedBlocks = {};\n    let pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n    for (let i = 0; i < pattern.length; ++i) {\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n        // order by key length\n        bNames.sort((a, b) => b.length - a.length);\n        // use block name with max length\n        const bName = bNames[0];\n        if (bName) {\n          const maskedBlock = createMask({\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite,\n            ...normalizeOpts(this.blocks[bName]),\n            parent: this\n          });\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n\n            // store block index\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n          i += bName.length - 1;\n          continue;\n        }\n      }\n      let char = pattern[i];\n      let isInput = (char in defs);\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n        continue;\n      }\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n      const def = isInput ? new PatternInputDefinition({\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar,\n        ...normalizeOpts(defs[char]),\n        parent: this\n      }) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n      this._blocks.push(def);\n    }\n  }\n  get state() {\n    return {\n      ...super.state,\n      _blocks: this._blocks.map(b => b.state)\n    };\n  }\n  set state(state) {\n    const {\n      _blocks,\n      ...maskedState\n    } = state;\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n    super.state = maskedState;\n  }\n  reset() {\n    super.reset();\n    this._blocks.forEach(b => b.reset());\n  }\n  get isComplete() {\n    return this._blocks.every(b => b.isComplete);\n  }\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n    super.doCommit();\n  }\n  get unmaskedValue() {\n    return this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n  get value() {\n    // TODO return _value when not in change?\n    return this._blocks.reduce((str, b) => str += b.value, '');\n  }\n  set value(value) {\n    super.value = value;\n  }\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n  _appendEager() {\n    var _this$_mapPosToBlock;\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) == null ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details;\n\n    // TODO test if it works for nested pattern masks\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n    return details;\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const blockIter = this._mapPosToBlock(this.value.length);\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n      const block = this._blocks[bi];\n      if (!block) break;\n      const blockDetails = block._appendChar(ch, {\n        ...flags,\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta2[bi]\n      });\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n    return chunkTail;\n  }\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (fromPos === toPos) return '';\n    let input = '';\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n    return input;\n  }\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n    return stopBefore;\n  }\n\n  /** Appends placeholder depending on laziness */\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n    const startBlockIter = this._mapPosToBlock(this.value.length);\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        var _blocks2;\n        const bDetails = b._appendPlaceholder((_blocks2 = b._blocks) == null ? void 0 : _blocks2.length);\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n    return details;\n  }\n\n  /** Finds block in pos */\n  _mapPosToBlock(pos) {\n    let accVal = '';\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.value;\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.value.length, 0);\n  }\n  _forEachBlocksInRange(fromPos, toPos, fn) {\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos);\n      // process first block\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n        }\n\n        // process last block\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    const removeDetails = super.remove(fromPos, toPos);\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n    return removeDetails;\n  }\n  nearestInputPos(cursorPos, direction) {\n    if (direction === void 0) {\n      direction = DIRECTION.NONE;\n    }\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.value.length;\n    }\n\n    // FORCE is only about a|* otherwise is 0\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      }\n\n      // forward flow\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled();\n\n      // backward flow\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n\n      // cursor.popState();\n      // if (\n      //   cursor.pushRightBeforeInput() &&\n      //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n      //   (!this.lazy || this.extractInput())\n      // ) return cursor.pos;\n\n      return 0;\n    }\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.value.length;\n\n      // backward flow\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n    return cursorPos;\n  }\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.value.length;\n    }\n    let total = 0;\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      total += b.totalInputPositions(bFromPos, bToPos);\n    });\n    return total;\n  }\n\n  /** Get block by name */\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n\n  /** Get all blocks by name */\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n}\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\n\nexport { MaskedPattern as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}